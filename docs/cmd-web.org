#+title: cmd/web

* main.go
:PROPERTIES:
:header-args: :tangle ../cmd/web/main.go
:END:
** package
Main package.

#+begin_src go
package main
#+end_src

** import
The flag library is used for command line parsing.
The log library is a simple package logging.
The net/http provides http client and server implementations.
The os package is used operating system functionality.

#+begin_src go
import (
	"flag"
	"log"
	"net/http"
	"os"
)
#+end_src

** structs
*** application

The application struct is used manage the app functionality and dependencies.
The errorLog and infoLog fields are of type log.Logger; they are used to overwrite the default loggers used.

#+begin_src go
// application dependencies
type application struct {
	errorLog	*log.Logger
	infoLog 	*log.Logger
}
#+end_src

** functions
*** main

Define the cli flags and parse for addr field.

Create custom loggers for info and error.

Use pointer semantic to initialize app from the application struct.
Define the errorLog and infoLog fields.

Overwrite the default server; this is good practice to avoid exposing Server globally.
It also allows for the ErrorLog to be replaced with the customer errorLog logger.
Set custom handlers from app.

Print server starting message to stdout via infoLogger.
Start server and handle for error.

#+begin_src go
func main() {
	// define cli flags
	addr := flag.String("addr", ":4000", "HTTP network address")
	flag.Parse()

	// custom loggers
	infoLog := log.New(os.Stdout, "INFO\t", log.Ldate|log.Ltime)
	errorLog := log.New(os.Stdout, "ERROR\t", log.Ldate|log.Ltime|log.Lshortfile)

	// initialize app from struct
	app := &application{
		errorLog: 	errorLog,
		infoLog: 	infoLog,
	}

	// overwrite default server to use custom errorLog
	srv := &http.Server{
		Addr: 		*addr,
		ErrorLog: 	errorLog,
		Handler: 	app.routes(),
	}

	// listen and server on 4000
	infoLog.Printf("Starting server on %s", *addr)
	err := srv.ListenAndServe()
	if err != nil {
		errorLog.Fatal(err)
	}
}
#+end_src

* handlers.go
:PROPERTIES:
:header-args: :tangle ../cmd/web/handlers.go
:END:
** package

#+begin_src go
package main
#+end_src

** import

#+begin_src go
import (
	"fmt"
	"net/http"
	"strconv"
	"text/template"
)
#+end_src

** methods
*** home

#+begin_src go
// define a home hanlder function
func (app *application) home(w http.ResponseWriter, r *http.Request) {
	// restrict the url from using catch-all pattern
	if r.URL.Path != "/" {
		app.notFound(w)
		return
	}

	// slice collection of templates to server
	files := []string{
		"./ui/html/home.page.tmpl",
		"./ui/html/base.layout.tmpl",
		"./ui/html/footer.partial.tmpl",
	}

	// create template definitions
	ts, err := template.ParseFiles(files...)
	if err != nil {
		app.serverError(w, err)
		return
	}

	err = ts.Execute(w, nil)
	if err != nil {
		app.serverError(w, err)
	}
}
#+end_src

*** showSnippet

#+begin_src go
// show specific snippet
func (app *application) showSnippet(w http.ResponseWriter, r *http.Request){
	// enforce positive value snippet id
	id, err := strconv.Atoi(r.URL.Query().Get("id"))
	if err != nil || id < 1 {
		app.notFound(w)
		return
	}
	fmt.Fprintf(w, "show snippet with ID %d", id)
}
#+end_src

*** createSnippet

#+begin_src go
// create a snippet
func (app *application) createSnippet(w http.ResponseWriter, r *http.Request){
	// enforce http post method
	if r.Method != http.MethodPost {
		w.Header().Set("Allow", http.MethodPost)
		app.clientError(w, http.StatusMethodNotAllowed)
		return
	}
	w.Write([]byte("create a snippet"))
}
#+end_src

* helpers.go
:PROPERTIES:
:header-args: :tangle ../cmd/web/helpers.go
:END:

* routes.go
:PROPERTIES:
:header-args: :tangle ../cmd/web/routes.go
:END:
** package
Package main.

#+begin_src go
package main
#+end_src

** import
Use net/http for http client and server functionality.

#+begin_src go
import (
	"net/http"
)
#+end_src

** methods
*** routes
Method for application struct.
Returns custom http.ServeMux

Create new mux server from http.NewServeMux.

Register the hanlder functions from app.

Register the handler for server static files.

Return mux with handlers.
#+begin_src go
func (app *application) routes() *http.ServeMux {
  // initialize new servemux
	mux := http.NewServeMux()

	// register the home function as the hanlder for root url
	mux.HandleFunc("/", app.home)
	mux.HandleFunc("/snippet", app.showSnippet)
	mux.HandleFunc("/snippet/create", app.createSnippet)

	// handle static file directory
	fileServer := http.FileServer(http.Dir("./ui/static"))
	mux.Handle("/static/", http.StripPrefix("/static", fileServer))

	return mux
}
#+end_src
